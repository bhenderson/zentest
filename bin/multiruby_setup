#!/usr/bin/env ruby -w

require 'multiruby'
include Multiruby

ENV.delete 'RUBYOPT'

# Take build parameters from ARGV after --
if idx = ARGV.index('--')
  ENV['CONFIGURE'] = ARGV[idx+1..-1].join(' ')
  ARGV.replace ARGV[0...idx]
end

ARGV << "help" if ARGV.empty?

Dir.chdir root_dir
setup_dirs(false)

# switch stdout to fd3. eval will only read from fd1. See 'setup'
FD = STDOUT.dup
begin
  io = IO.for_fd(3)
  io.sync = true
  STDOUT.reopen io
rescue Errno::EBADF, ArgumentError
  # if fd3 is not open, STDOUT will remain unchanged.
end

# TODO rename?
def shell(*args) FD.puts(*args) end

ARGV.each_with_index do |spec, index|
  case spec
  when "-h", "--help", "help" then
    help
    exit 0
  when "the_usual" then # TODO: update #help
    ARGV.push(*VERSIONS.map { |v| "mri:tar:#{v.gsub(/_/, '.')}" })
    ARGV << "build" << "update:rubygems" << "the_usual:gems"
  when "the_usual:gems" then
    system "multigem install --no-ri --no-rdoc rake minitest ZenTest gemcutter rubyforge hoe"
  when "build" then
    build_and_install
  when "clean" then
    clean
  when "list" then
    list
  when /rm:(.*)/ then
    rm $1
  when "rubygems:merge" then
    merge_rubygems
  when "rubygems:update", "update:rubygems" then
    update_rubygems
    ARGV << "build"
  when "update" then
    update
  when "tags" then
    p tags
  when "mri:svn:current" then
    ARGV << "mri:svn:releases" << "mri:svn:branches" << "build"
  when "mri:svn:releases" then
    TAGS.each do |v|
      latest = mri_latest_tag v
      abort "Can't find tag #{v}" unless latest
      ARGV << "mri:svn:tag:#{latest}:mri_rel_#{v}"
    end
    ARGV << "build"
  when /mri:svn:branch:(.*)/ then
    ver = "branches/ruby_#{$1}" unless ver == "trunk"
    svn_co "#{MRI_SVN}/#{$1}", "mri_#{$1}"
    ARGV << "build"
  when "mri:svn:branches" then
    BRANCHES.each do |v|
      ARGV << "mri:svn:branch:#{v}"
    end
    ARGV << "build"
  when /mri:svn:tag:(.*):(.*)/ then
    svn_co "#{MRI_SVN}/tags/#{$1}", $2
    ARGV << "build"
  when /mri:svn:tag:(.*)/ then
    ARGV << "mri:svn:tag:#{$1}:#{$1}" << "build"
  when /mri:list:(.*)/ then
    v   = $1
    ver = v[/\d+\.\d+/]
    url = "#{RUBY_URL}/#{ver}/"

    puts matching_versions(url, v).join("\n")
  when /mri:tar:(.*)/ then
    fetch_tar $1
    ARGV << "build"
  # mrs functions
  when 'use' then
    # TODO separate method
    version = ARGV[index+1] or abort 'version string required'
    bin = dir = gem = ver = ''
    unless version == 'system'
      dir  = Dir["#{root_dir}/install/#{version}"].first or
        abort "unknown version #{version}"
      dir  = File.readlink dir if test ?l, dir
      ver  = File.basename dir
      bin  = "#{dir}/bin"
      gem  = Dir["#{dir}/lib/ruby/gems/*"].first.to_s
    else
      ver  = version
    end
    # remove any previous multiruby from path and append this one.
    path = ENV['PATH'].split(File::PATH_SEPARATOR).
             delete_if{|p| p =~ /multiruby/}

    path.unshift(bin) if bin

    shell 'export PATH='              + path.join(File::PATH_SEPARATOR)
    shell 'export GEM_HOME='          + gem
    shell 'export GEM_PATH='          + gem
    shell 'export MULTIRUBY_CURRENT=' + ver
    shell 'hash -r' # clear shell hashed locations
    exit 0
  when 'alias' then
    # setup aliases
    version, name = ARGV[index+1,2]
    in_install_dir do
      # symlink force isn't working
      FileUtils.rm_f name if test ?l, name
      FileUtils.ln_sf version, name
    end
    exit 0
  # setup shell function in .bashrc
  when 'setup' then
    puts 'Adding shell function to ~/.bashrc'
    File.open File.expand_path('~/.bashrc'), 'a' do |f|
      # eval output. Anything on fd3 will not get eval'd. That's why we
      # switched stdout to it. Then close fd3.
      f.puts <<-EOS.gsub!(/^ */,'')

        ### multiruby ###
        # shell function
        mrs() { exec 3>&1; eval \"$(#{__FILE__} \"$@\")\"; exec 3>&-; }
        # tab completion function
        _mrs() {
          local cur=${COMP_WORDS[COMP_CWORD]}
          COMPREPLY=( $( compgen -W '`ls #{root_dir}/install/`' -- $cur ) )
        }
        complete -F _mrs mrs
        mrs use default
        ### multiruby ###
      EOS
    end
  else
    warn "unknown spec #{spec}"
  end
end
